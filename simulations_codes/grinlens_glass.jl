module Grinlens_glass

export Parameters, Observables, propagate

include("./gaussianbeam.jl")
using .GaussianBeam

# discrete model for continuous grin lens

# parameters
Base.@kwdef struct Parameters
    # medium parameters
    n       # index of refraction
    λ       # wavelength (m)
    P       # power of laser (W)
    k       # thermic diffusion coefficient (W/m/K)
    α       # absorption coefficient (1/m)
    dndT    # index variation coefficient (1/K)
    rho     # kg m^-3
    Cp      # J kg-1 K-1
    focale::Function  # thermally induced focal length of liquid slice


    # input beam parameters (s)
    z0      # initial position of the waist without lens effect (m)
    w0      # initial waist of the beam (m)

    # iteration parameters
    l       # width of the liquid slices (m)
    steps   # position along the tank to compute on (m)
    t       # time step
end

# default parameters
function Parameters(;
    n = 1.473,           # borosilicate index
    λ = 920e-9,         # wavelength of 2P laser (m)
    P = 0.5,            # 500 mW is average power (W)
    k = 1.2,            # borosilicate thermic diffusion coefficient (W/m/K)
    α = 0.20857,       # borosilicate absorption coefficient (1/m)
    dndT = 3.4e-6,       # borosilicate thermo optic coefficient 20° (1/K) "Thermooptic Coefficients of Some Standard Reference Material Glasses John M. Jewel1"
    rho = 2230,         # kg m^-3
    Cp = 830,          # J kg-1 K-1
    focale = Nothing,   # let default definition
    z0 = 1e-2,          # initial position of the beam is 1 cm far from entry (m)
    w0 = 6.5e-6,        # initial waist of laser set to 6.5 µm (usually lower) (m)
    l = 1e-5,           # propagation step of 10 µm (l)
    steps = 0:l:4e-2,   # total computation of propagation on 4 cm of water (m)
    t=Inf,
)
    if focale == Nothing # define default model depending on medium parameters
        focale = (l,w) ->  (π * k * w^2 / ( α * P * l * dndT))*(1+(w^2/(4*(k/(rho*Cp))))/(2*t))  # whinnery 2002
    end

    return Parameters(n,λ,P,k,α,dndT,rho,Cp,focale,z0,w0,l,steps,t)
end

# observables
mutable struct Observables
    focal::Vector   # focal length of liquid slice lens (m)
    shift::Vector   # focal shift generated by liquid slice lens (m)
    magnif::Vector  # magnification for liquid slice lens
    pos::Vector     # position of the waist after liquid slice lens (m)
    waist::Vector   # size of the waist after liquid slice lens (m)
    wonlens::Vector # beam width on the lens (m)
    dist::Vector    # distance from lens to object waist (m)
    minwidth        # minimal width of the beam (m)
    minwidthpos     # first position of minimal width (m)
end

Observables(n::Int) = Observables(zeros(n),zeros(n),zeros(n),zeros(n),zeros(n),zeros(n),zeros(n),Nothing,Nothing) # init arrays


# simulate a gaussian beam propagation in water
function propagate(n,λ,focale,z0,w0,l,steps,t)
    # observables
    o = Observables(length(steps))   # length of vector

    # loop for each element lens
    for (i,z) in enumerate(steps)
        # compute lens effect
        sa = z0 - z                         # algebric distance lens-object (m)
        w0a = w0                            # waist before lens (m)
        zra = rayleigh_length(n, w0a, λ)    # Rayleigh length before lens (m)
        wa = gaussian_width(n, sa, w0a, λ)  # beam width at lens position (m)
        fprime = focale(l, wa)              # thermally induced lens' focal length (m)
        sb = sprime(sa, fprime, zra)        # algebric distance lens-image (m)
        mag = magnification(sa, fprime, zra) # magnification in this configuration
        w0b = w0a * mag                     # waist after lens (m)

        # update beam properties
        z0 = z + sb                         # update z0 with new absolute beam position
        w0 = w0b                            # update w0 with new beam waist

        # update observables
        o.focal[i] = fprime
        o.shift[i] = (sb-sa)
        o.magnif[i] = mag
        o.pos[i] = z0
        o.waist[i] = w0
        o.wonlens[i] = wa
        o.dist[i] = sa
    end
    (o.minwidth, pos) = findmin(o.wonlens)  # get minimal width and its position
    o.minwidthpos = steps[pos]            # convert it to meter
    return o
end

propagate(p::Parameters) = propagate(p.n, p.λ, p.focale, p.z0, p.w0, p.l, p.steps,p.t)

end
